This example determines the relationships between people.

family.py
    This has the primary data used by the rest of the rules.  This data is
    established as universal facts so that it remains after an engine.reset()
    is done.

fc_example.krb
    Forward-chaining example.  This only uses forward-chaining rules, which
    means that all possible relationships are determined when the rule base is
    activated.

bc_example.krb
    Backward-chaining example.  This only uses backward-chaining rules, though
    these rules are not very efficient.

bc2_example.krb
    Backward-chaining example.  This also only uses backward-chaining rules,
    but a few rule optimizations have been made which results in this rule base
    running 100 times faster than bc_example.krb.

example.krb
    Combined rule base.  This has some forward-chaining rules, some
    (unoptimized) backward-chaining rules, and produces plans that return the
    relationship when run.  (This is a poor use of plans, but demonstrates the
    syntax and underlying principles).

test.py
    Driver program.  Run:
        >>> from examples.family_relations import test
        >>> test.fc_test([person1='bruce'])
        >>> test.bc_test([person1='bruce'])
        >>> test.bc2_test([person1='bruce'])
        >>> test.test([person1='bruce'])
        >>> test.general([person1=None], [person2=None], [relationship=None])

    The last function uses the bc2_example rule base.  You can pass whatever
    combinations of values you like.  If you want to specify person1 and/or
    person2, pass their name; otherwise any person will match.  For the
    relationship, pass a tuple.  Use '$var_name' strings in the tuple for
    pattern variables.  You can also have nested tuples (as some of the
    relationships are nested tuples).
