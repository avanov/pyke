# $Id$
#
# Copyright Â© 2008 Bruce Frederiksen
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.


#
# This logic adds inheritance to the database tables.  This means that when
# table A includes a foreign key to table B, all of the columns in table B are
# inherited by table A and can be used as if they appeared directly in table A.
# The logic will automatically add the necessary joins from table A to table B.
# This inheritance goes on any number of levels, so columns inherited by
# table B are also included in table A.
#
# This example is simplified in the following ways:
#    - it is assumed that the primary key to all tables is called 'id'.
#    - it is assumed that all foreign keys linking to table 'B' are called
#      'B_id'.
#    - functions and operators are not supported (in the 'where' or 'select'
#      clause).
#        - thus no aggregation is possible; so no need for a "group by" clause
#          which would otherwise be added automatically.
#    - updates are not supported (insert, update, delete).
#    - column_name qualification is not supported to disambiguate between
#      multiple columns being inherited with the same name.

get_data
    # $starting_data is a tuple of table_names that we will have ids for when
    # we call the plan function.  These ids are passed to the plan function as
    # a dict mapping table_names to ids.
    # $needed_data is a tuple describing the data that should be returned (as
    # a dict).  It is composed of the following:
    #     column_name
    #         -- binds a single (ie, unique) value to column_name
    #     (name, (options), needed_data...)
    #         -- binds a tuple of dictionaries to name
    #         -- options can be:
    #               (linked_to table_name)
    #                   -- table_name is the "1" table in the many_to_1 link
    #               (order_by 'asc'|'desc'|column_name...)
    #         -- needed_data can only be a column_name at this point
    #            (no nested multirow queries)
    use get_data($starting_data, $needed_data) \
        taking(db_cursor, starting_data)
    when
        #python print "get_data: starting_data: %s" % str($starting_data)
        #python print "get_data: needed_data: %s" % str($needed_data)
        !get_data2($starting_data, $needed_data, $multi_plans, $unique_queries)
        !process_unique_queries($unique_queries)
            ans = {}
            $$(db_cursor, starting_data, ans)
    with
        for row_name, plan in $multi_plans:
            ans[row_name] = plan(db_cursor, starting_data)
        return ans

get_data2
    # This processes the each element in $needed_data.  It creates two tuples:
    # $multi_plans, $unique_queries.
    # 
    # Each request for multi-row data in $needed_data results in an element in
    # $multi_plans.  This element is a two-tuple: (row_name, retrieval_fn)
    # where the retrieval_fn takes two arguments: db_cursor and starting_data.
    #
    # Each request for single-row (unique) data in $needed_data results in an
    # element in $unique_queries.  This element is a three-tuple:
    #     from clause, which is a tuple starting with table_name_a followed by:
    #                  (table_name_b, from_table, from_columns, b_columns)...
    #     select clause, which is a column_name in the last table of the from
    #                    clause
    #     name binding, which will be the key in the resulting dict
    #
    # No plan is returned.
    use get_data2($starting_data, $needed_data, $multi_plans, $unique_queries)
    when
        python print "get_data2(%s, %s, _, _)" % ($starting_data, $needed_data)

        # Note difference between multi_plans and $multi_plans!
        python multi_plans = []
        python unique_queries = []

        forall
            $needed in $needed_data
        require
            get_data3($starting_data, $needed, $multi_plan, $unique_queries1)
            python if $multi_plan: multi_plans.append($multi_plan)
            python if $unique_queries1: unique_queries.append($unique_queries1)
        $multi_plans = tuple(multi_plans)
        $unique_queries = tuple(unique_queries)

get_data3_multi
    # This handles an individual $needed_data request for get_data2 (above).
    use get_data3($starting_data, ($row_name, $options, *$multi_data),
                  ($row_name, $multi_plan), None)
    when
        # Multi-row request.
        special.claim_goal()
        get_multi($starting_data, $options, $multi_data, $multi_plan)

get_data3_unique
    use get_data3($starting_data, $unique_data, None, $unique_out)
    when
        # Single-row (unique) request.
        get_unique($starting_data, $unique_data, $unique_out)

get_unique_direct
    # $unique_out is a tuple of:
    #     from clause, which is a tuple starting with table_name_a followed by:
    #         (table_name_b, from_table, from_columns, b_columns)...
    #     select clause, which is a column_name
    #     name binding, which is a string
    use get_unique($starting_data, $column, ($from_clause, $column, $column))
    when
        # This handles the case where $column is directly in one of the
        # $starting_data tables.
        lookup_column($column, $starting_data, $from_clause)
        special.claim_goal()
        # lookup_column sets $from_clause to None if there were multiple
        # matches... (which is an error and should cause get_unique to fail).
        check $from_clause

get_unique_indirect
    use get_unique($starting_data, $column, ($from_clause, $column, $column))
    when
        # This handles the case where $column is inherited into one of the
        # $starting_data tables.
        lookup_indirect(1, $column, $starting_data, $from_clause)

lookup_column
    use lookup_column($column, $starting_data, $ans)
    when
        # Find all of the tables in $starting_data that have $column.
        find_columns($column, $starting_data, $tables)
        unique_table($column, $tables, $ans)

unique_table_success
    use unique_table($_, ($table), ($table))
    when
        # A single table was found: Success!
        special.claim_goal()

unique_table_not_found
    use unique_table($_, (), $_)
    when
        # No tables were found: fail
        special.claim_goal()
        check False

unique_table_dups
    use unique_table($column, $tables, None)
    when
        # Multiple tables were found: succeed with None to flag problem...
        python print "duplicate column %s, found in %s" % ($column, $tables)

find_columns
    use find_columns($column, $tables_in, $matching_tables)
    when
        python matching_tables = []
        forall
            $table in $tables_in
            schema.column($table, $column, $_, $_, $_, $_, $_)
            python matching_tables.append($table)
        $matching_tables = tuple(matching_tables)

#find_columns_done
#    use find_columns($_, (), ())
#
#find_columns_in_next
#    use find_columns($column, ($table, *$rest), ($table, *$tables_out))
#    when
#        schema.column($table, $column, $_, $_, $_, $_, $_)
#        special.claim_goal()
#        !find_columns($column, $rest, $tables_out)
#
#find_columns_not_in_next
#    use find_columns($column, ($_, *$rest), $tables_out)
#    when
#        !find_columns($column, $rest, $tables_out)

lookup_indirect
    use lookup_indirect($depth, $column, $starting_data, $from_clause)
    when
        #python print "lookup_indirect: "
        #                "find_depth(%s, %s, %s, _, _)" %
        #                ($depth, $column, $starting_data)
        !find_depth($depth, $column, $starting_data, $got_depth, $tables)
        #python print "lookup_indirect: "
        #                "lookup_indirect2(%s, %s, %s, %s, %s, _)" %
        #                ($depth, $column, $starting_data, $got_depth, $tables)
        lookup_indirect2($depth, $column, $starting_data, $got_depth, $tables,
                         $from_clause)

lookup_indirect2_success
    use lookup_indirect2($_depth, $_column, $_starting_data, $_got_depth,
                         ($from_clause), $from_clause)
    when
        # Found it!
        special.claim_goal()

lookup_indirect2_next_depth
    use lookup_indirect2($depth, $column, $starting_data, True, (),
                         $from_clause)
    when
        # $column not found, but the inherited tables haven't run out yet!
        special.claim_goal()
        $depth2 = $depth + 1
        lookup_indirect($depth2, $column, $starting_data, $from_clause)

lookup_indirect2_dups
    # $got_depth must be True if there are multiple $froms.  If $got_depth is
    # False, let lookup_indirect2 fail silently...
    use lookup_indirect2($_depth, $column, $_starting_data, True, $froms, $_)
    when
        python print "duplicate tables for %s: %s" % \
                         ($column, tuple(from_[0] for from_ in $froms))
        check False

find_depth_done
    use find_depth($_depth, $_column, (), False, ())

find_depth_step
    use find_depth($depth, $column, ($table, *$rest), $got_depth, $tables_out)
    when
        ($got_depth1, $from) = find_depth1(engine, $depth, $column, $table)
        find_depth($depth, $column, $rest, $got_depth2, $tables_out2)
        $got_depth = $got_depth1 or $got_depth2
        $tables_out = $from + $tables_out2

#find_depth2_false
#    use find_depth2($depth, $column, $_table, $rest, False, (),
#                    $got_depth, $tables_out)
#    when
#        special.claim_goal()
#        find_depth($depth, $column, $rest, $got_depth, $tables_out)
#
#find_depth2_true
#    use find_depth2($depth, $column, $table, $rest, True, $froms,
#                    True, $tables_out)
#    when
#        special.claim_goal()
#        find_depth($depth, $column, $rest, $_got_depth, $rest_out)
#        $tables_out = $froms + $rest_out

process_unique_queries_done
    use process_unique_queries(()) taking(db_cursor, starting_data, dict)
    with
        pass

process_unique_queries_step
    use process_unique_queries((($from, $select, $key), *$rest)) \
        taking(db_cursor, starting_data, dict)
    when
        $select2 = "%s.%s" % (($from[0] if len($from) == 1 else $from[-1][0]),
                              $select)
        python print "process_unique_queries_step: " \
                     "process_query(%s, %s, _, _)" %  \
                        (($from, ($select2,), ($key,)), $rest)
        !process_query(($from, ($select2), ($key)), $rest, $unrelated_queries,
                       $combined_query)
        python print "process_unique_queries_step: combined_query is: %s" % \
                        str($combined_query)
        !run_query($combined_query)
            $$(db_cursor, starting_data, dict)
        !process_unique_queries($unrelated_queries)
            $$(db_cursor, starting_data, dict)

process_query_done_n
    use process_query($query, (), (), $query)

process_query_match_n
    use process_query((($table1, *$joins1), $select_columns1, $dict_keys1),
                      ((($table1, *$joins2), $select_column2, $dict_key2),
                       *$rest),
                      $unrelated_queries,
                      $combined_query)
    when
        special.claim_goal()
        #python print "merge_joins(%s, %s, $merged_join)" % 
        #                ($joins1, $joins2)
        merge_joins($joins1, $joins2, $merged_join)
        $select2 = "%s.%s" % (($table1 if not $joins2 else $joins2[-1][0]),
                              $select_column2)
        process_query((($table1, *$merged_join),
                           ($select2, *$select_columns1),
                           ($dict_key2, *$dict_keys1)),
                      $rest, $unrelated_queries, $combined_query)

process_query_match
    use process_query($query1, ($unrelated_query1, *$rest),
                      ($unrelated_query1, *$unrelated_queries), $combined_query)
    when
        process_query($query1, $rest, $unrelated_queries, $combined_query)

merge_join_match
    use merge_joins(($first_join, *$rest_joins1), ($first_join, *$rest_joins2),
                    ($first_join, *$merged_joins))
    when
        special.claim_goal()
        merge_joins($rest_joins1, $rest_joins2, $merged_joins)

merge_join_no_match
    use merge_joins($joins1, $joins2, $merged_joins)
    when
        $merged_joins = $joins1 + $joins2

run_query
    use run_query((($table1, *$joins1), $select_columns, $dict_keys)) \
        taking(db_cursor, starting_data, dict)
    when
        #python print "make_from_clause(%s, %s, $from_clause)" % 
        #                ($table1, $joins1)
        !make_from_clause($table1, $joins1, $from_clause)
        $sql_command = "select %s\n  from %s\n where %s.id = %%(id)s" % \
                           (', '.join($select_columns), $from_clause, $table1)
    with
        db_cursor.execute($sql_command, {'id': starting_data[$table1]})
        assert db_cursor.rowcount == 1, \
            'expected unique row, got %d rows from "%s"' % \
              (db_cursor.rowcount, sql_command)
        dict.update(zip($dict_keys, db_cursor.fetchone()))

make_from_clause_done
    use make_from_clause($from_in, (), $from_in)

make_from_clause_next
    use make_from_clause($from_in,
                         (($table2, $from_table, $from_cols, $to_cols), *$rest),
                         $from_clause)
    when
        $from1 = "%s\n           inner join %s on (%s)" % \
                   ($from_in, $table2,
                    ' AND '.join("%s.%s = %s.%s" %
                                    ($from_table, from_col, $table2, to_col)
                                 for from_col, to_col
                                 in zip($from_cols, $to_cols)))
        make_from_clause($from1, $rest, $from_clause)

get_multi
    use get_multi($starting_data, $options, $multi_data, $plan)
    when
        $linked_to = dict($options).get('linked_to')
        $order_by = dict($options).get('order_by')
        get_multi2($starting_data, $multi_data, $linked_to, $order_by, $plan)

get_multi2_no_linked_to
    use get_multi2($starting_data, $multi_data, None, $order_by, $plan)
    when
        special.claim_goal()
        $unique_table in $starting_data
        get_multi3($unique_table, $multi_data, $order_by, $plan)

get_multi2_linked_to
    use get_multi2($starting_data, $multi_data, $linked_to, $order_by, $plan)
    when
        check $linked_to in $starting_data
        get_multi3($linked_to, $multi_data, $order_by, $plan)

get_multi3
    use get_multi3($unique_table, $multi_data, $order_by, $plan)
    when
        schema.many_to_1($multi_table, $unique_table, ($multi_link_column), $_)
        get_data2(($multi_table), $multi_data, (), $unique_queries)
        process_multi_queries($unique_queries, $combined_query)
        run_multi_query($unique_table, $combined_query, $multi_link_column,
                        $order_by) as $plan

process_multi_queries_done
    use process_multi_queries((), ())

process_multi_queries_step
    use process_multi_queries((($from, $select, $key), *$rest), $combined_query)
    when
        $select2 = "%s.%s" % (($from[0] if len($from) == 1 else $from[-1][0]),
                              $select)
        process_query(($from, ($select2), ($key)), $rest, (), $combined_query)

run_multi_query
    use run_multi_query($unique_table,
                        (($table1, *$joins1), $select_columns, $dict_keys),
                        $multi_link_column, $order_by) \
        taking (db_cursor, starting_data)
        # plan returns tuple of dictionaries
    when
        !make_from_clause($table1, $joins1, $from_clause)
        # FIX: Add order_by
        $sql_command = "select %s\n  from %s\n where %s.%s = %%(id)s" % \
                           (', '.join($select_columns), $from_clause,
                            $table1, $multi_link_column)
    with
        db_cursor.execute($sql_command, {'id': starting_data[$unique_table]})
        return tuple(dict(zip($dict_keys, row)) for row in db_cursor.fetchall())

bc_extras
    def find_depth1(engine, depth, column, table):
        got_depth = False
        ans_joins = []
        for (to_table, joins), bogus_plan1 \
         in engine.prove_n("schema", "links_to", (depth, table), 2):
            got_depth = True
            for bogus_vars, bogus_plan1 \
             in engine.prove_n("schema", "column", (to_table, column), 5):
                ans_joins.append((table,) + joins)
        return got_depth, tuple(ans_joins)

    def print_fail(msg):
        print msg
        return False

