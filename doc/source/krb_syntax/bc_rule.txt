restindex
    crumb: Bc_rule
    page-description:
        The syntax of a backward-chaining rule.
    /description
    format: rest
    encoding: utf8
    output-encoding: utf8
    include: yes
    initialheaderlevel: 1
/restindex

=============================================
Bc_rule Syntax
=============================================

Bc_rule
==========

Backward-chaining_ rules_ have four parts:

#. A unique name.
#. A ``use`` clause.
#. An optional ``when`` clause.
#. An optional ``with`` clause.

::

    bc_rule ::= IDENTIFIER ':' NL INDENT
                    use
                    [when]
                    [with]
                DEINDENT

The ``IDENTIFIER`` is the unique name for this rule_ and is used as the
corresponding python function name in the generated <rb_name>_bc.py file.

Use Clause
============

The ``use`` clause is the **then** part of the rule_.  It identifies the
*goal* that this rule_ is trying to prove.

    use ::= 'use' IDENTIFIER '(' {pattern,} ')'
            ['taking' '(' <python_arg_spec> ')'] NL

Notice that it uses a single ``IDENTIFIER``.  The `rule base`_ name is implied
as the `rule base category`_ name for the `rule base`_ containing this rule_.

Taking Clause
----------------

The ``use`` clause also defines parameters to the plan_ function (if one is
used for this rule_) with the optional ``taking`` sub-clause.

The *python_arg_spec* is not parsed by pyke, but simply copied to the
output plan_ function.  Do **not** use ``$`` with these parameters.

When Clause
==============

The ``when`` clause is the **if** part of the rule_.  It defines the
premises that must be true for this rule to succeed.

If the ``when`` clause is omitted, the only
requirement for the rule_ to succeed is that the ``use`` clause
patterns_ match the goal.

If the ``when`` clause is used, the rule_ succeeds for each
combination of true premises.

::

    when ::= 'when' NL INDENT
                 {bc_premise NL}
             DEINDENT

    bc_premise ::= ['!'] goal_name '(' {pattern,} ')' plan_spec
                 | python_premise

    goal_name ::= name '.' name
                | name

    name ::= IDENTIFIER
           | '$'IDENTIFIER

If a single *name* is used in the *bc_premise*,
the `rule base category`_ for the current `rule base`_ is assumed.

If two *names* are used in the *bc_premise*, the first may name a `rule
base category`_ or a `fact base`_.

If a `rule base category`_ name is used (or assumed),
the currently active_ `rule base`_ for that category_ is used to prove the
premise.  Note that if the `rule base category`_ name is omitted, and
therefore assumed to be the current `rule base's`_ `rule base category`_,
the current `rule base`_ may not be the active_ `rule base`_ for that
category_.  It could be the case, that a derived `rule base`_ is the
active_ `rule base`_.  In that case, the derived `rule base`_ is used to
prove the premise. 

Here are the links to the definitions for pattern_ and python_premise_.

Plan_spec
------------

A *plan_spec* is required for all premises that return plans_.
This shows what to do with the returned plan_ function::

    plan_spec ::= step_opt NL
                | step_opt NL INDENT
                      {<python_statement> NL}
                  DEINDENT
                | 'as' '$'IDENTIFIER NL

    step_opt ::=
               | 'step' NUMBER

The plan_ function itself is indicated by ``$$`` in the *python_statement*.
The result of this function
may be assigned to a python variable, but not a `pattern variable`_
(``$variable``).
Parameters from the ``taking`` clause may be passed to the plan_ function.

With multiple premises, the *plan_specs* without ``step`` clauses are
executed first in the order that they appear.  Then the *plan_specs*
with ``step`` clauses are executed in ascending sequence by the NUMBER in
the ``step`` clause.  It is permissible for the NUMBER to be negative or a
float.

If the ``as`` clause is used, the plan_ function is bound to the
`pattern variable`_ as a python function.  This allows you to call the
function (or not) as you please.  The parameters required are defined in
the ``taking`` clause of the rule_ used to prove the premise.

With Clause
==============

The ``with`` clause contains python
statements for the plan_ produced by this rule_.  These python statements may
include `pattern variables`_ whose values will be substituted into the
statements when finalizing the final plan_.

::

    with ::= 'with' NL INDENT
                 {<python_statement> NL}
             DEINDENT

These *python_statements* are included in the plan_ function after the
calls to all of the subordinate plan_ functions from all of the *plan_specs*
in the ``when`` clause.

If the ``with`` clause is omitted, but the ``when`` clause has *plan_specs*
(excluding ``as`` specs), a plan_ function is still generated for this
rule_ so that the subordinate plan_ functions may still be called.

The *python_statements* are not parsed.  They are simply scanned for ``$``
`pattern variables`_ that don't occur in string literals or comments.
The resulting plan_ will substitute the values bound to these variables_
into the code.

But note that this substitution isn't done until after the entire
top-level goal has been proven.  So it is permissible to use
unbound `pattern variables`_, so long as they will be bound to values by
subsequent rules_.

.. _active: ../using_pyke.html#setting-up-each-case
.. _backward-chaining: ../overview/rules/backward_chaining.html
.. _category: `rule base category`_
.. _fact base: ../overview/knowledge_bases/fact_bases.html
.. _pattern: pattern.html
.. _patterns: pattern_
.. _pattern variable: pattern.html#pattern-variable
.. _pattern variables: `pattern variable`_
.. _plan: ../overview/plans.html
.. _plans: plan_
.. _python_premise: python_premise.html
.. _rule: ../overview/rules/index.html
.. _rules: rule_
.. _rule base: ../overview/knowledge_bases/rule_bases.html
.. _rule base's: `rule base`_
.. _rule base category:
       ../overview/knowledge_bases/rule_bases.html#rule-base-categories
.. _variables: `pattern variable`_

