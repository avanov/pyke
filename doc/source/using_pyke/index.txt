.. $Id$
.. 
.. Copyright Â© 2007-2010 Bruce Frederiksen
.. 
.. Permission is hereby granted, free of charge, to any person obtaining a copy
.. of this software and associated documentation files (the "Software"), to deal
.. in the Software without restriction, including without limitation the rights
.. to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
.. copies of the Software, and to permit persons to whom the Software is
.. furnished to do so, subject to the following conditions:
.. 
.. The above copyright notice and this permission notice shall be included in
.. all copies or substantial portions of the Software.
.. 
.. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
.. IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
.. FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
.. AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
.. LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
.. OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
.. THE SOFTWARE.

restindex
    crumb: Using Pyke
    page-description:
        How your Python program calls Pyke.
    /description
    section-pages: , creating_engine, adding_facts, proving_goals, other_functions
    format: rest
    encoding: utf8
    output-encoding: utf8
    include: yes
    initialheaderlevel: 2
/restindex

uservalues
    filedate: $Id$
/uservalues

==========
Using Pyke
==========

This describes how to call Pyke from your Python program.

Getting Started
===============

.. this code is hidden and will set __file__ to the doc/examples directory.
   >>> import os
   >>> __file__ = \
   ...   os.path.join(os.path.dirname(os.path.dirname(os.getcwd())),
   ...                'examples')

The simplest use of Pyke involves three steps:

#.  `Create an engine`_ object.

    >>> from pyke import knowledge_engine

    >>> my_engine = knowledge_engine.engine(__file__)

    The step compiles the Pyke source files, if out of date, and loads the
    `knowledge bases`_.

    There are three kinds of Pyke source files:

    #.  `.kfb files`_ define `fact bases`_, which are compiled into .fbc pickle
        files.
    #.  `.krb files`_ define `rule bases`_, which are compiled into 1 to 3 .py
        Python source files.
    #.  `.kqb files`_ define `question bases`_, which are compiled into .qbc
        pickle files.

#.  Activate `rule bases`_.

    >>> my_engine.activate('bc_related')

    You may chose one or more rule bases to activate.
    
    .. note::

       Even if you only have one rule base, you must still activate it.

    This is when the `forward-chaining rules`_ are run.

#.  Prove_ goal_.

    >>> my_engine.prove_1_goal('bc_related.father_son(bruce, $son, ())')
    ({'son': 'david'}, None)

    The goal might be met by simply matching an already known fact_, or
    through the use of `backward-chaining rules`_.

Then if you want to prove another goal, you can just repeat the last step.
In this case, the `forward-chaining rules`_ are only run once and all goals
operate against the same set of known facts.

    >>> my_engine.prove_1_goal('bc_related.father_son(thomas, $son, ())')
    ({'son': 'tim'}, None)

Dynamically Asserting Facts
===========================

To dynamically assert_ facts_ within your Python program, a new step is added:

#.  Create an engine_ object.

    >>> from pyke import knowledge_engine

    >>> my_engine = knowledge_engine.engine(__file__)

#.  Assert_ facts_.

    >>> my_engine.assert_('family2', 'son_of', ('spike', 'david'))

    These facts must be asserted prior to activating the rule bases so that
    they are available to the `forward-chaining rules`_.

#.  Activate `rule bases`_.

    >>> my_engine.activate('bc_related')

#.  Prove goal_.

    >>> my_engine.prove_1_goal('bc_related.father_son(david, $son, ())')
    ({'son': 'spike'}, None)

Using Different Facts for Different Cases
=========================================

But if you want to prove goals against different sets of facts or using
different rule bases, you need to reset_ the Pyke engine:

#.  Create an ``engine`` object.

    >>> from pyke import knowledge_engine

    >>> my_engine = knowledge_engine.engine(__file__)

#.  Assert_ facts_ for first case.

    >>> my_engine.assert_('family2', 'son_of', ('spike', 'david'))

#.  Activate `rule bases`_.

    >>> my_engine.activate('bc_related')

#.  Prove goal_ for first case.

    >>> my_engine.prove_1_goal('bc_related.father_son(david, $son, ())')
    ({'son': 'spike'}, None)

#.  Reset the Pyke engine.

    >>> my_engine.reset()

    This erases all of the case specific facts that you asserted in step 2, as
    well as all of the facts asserted by the `forward-chaining rules`_.

    It also deactivates all of the `rule bases`_, so you'll need to call
    activate again after asserting your facts.

#.  Assert facts_ for second case.

    >>> my_engine.assert_('family2', 'son_of', ('felix', 'david'))

#.  Activate `rule bases`_.

    >>> my_engine.activate('bc_related')

#.  Prove goal_ for second case.

    >>> my_engine.prove_1_goal('bc_related.father_son(david, $son, ())')
    ({'son': 'felix'}, None)

