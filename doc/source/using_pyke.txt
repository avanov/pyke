restindex
    crumb: Using Pyke
    page-description:
        How your python program uses pyke.
    /description
    format: rest
    encoding: utf8
    output-encoding: utf8
    include: yes
/restindex

===================================
Using Pyke
===================================

There isn't that much to using pyke.  Generally, all the functions you need
are provided directly by the ``pyke`` package:

    >>> import pyke

Initializing Pyke
===============================

There are two functions to initialize pyke:

load(paths = ('.',), load_fc = True, load_bc = True)
    The ``load`` function may only be called once.  It expects either a single
    directory or a sequence directories.  It recursively walks each directory
    looking for `.krb files`_.  Each `.krb file`_ that it finds is compiled,
    if out of date, and then the resulting python modules imported.
    This causes all of the `rule bases`_ to be loaded.
add_universal_fact(kb_name, fact_name, args)
    The ``add_universal_fact`` function is called once per fact_.  These facts_
    are never deleted and apply to all *cases*.

Setting up Each Case
===========================

Pyke is designed to be run multiple times for multiple *cases*.  In
general each case has its own set of starting facts_ and may use different
`rule bases`_, depending on the situation.

Three functions initialize each case:

reset()
    The ``reset`` function is called once to delete all of the `case specific
    facts`_ from the last run.  It also deactivates all `rule bases`_.
assert_(kb_name, fact_name, args)
    Call ``assert_`` (or the equivalent, ``add_case_specific_fact``,
    see `Other Functions`_, below) for each starting fact_ for this case.
activate(\*rb_names)
    Then call ``activate`` to activate the appropriate `rule bases`_.  This
    may be called more than once, if desired, or it can simply take multiple
    arguments.

Pyke is now ready to prove goals for this case!

Proving Goals
======================

Two functions are provided that cover the easy cases.  More general
functions are provided in `Other Functions`_, below.

prove_1(kb_name, entity_name, fixed_args, num_returns)
    Returns the first proof as two results: a tuple whose len == num_returns
    containing the returned values, and a plan_.  The plan_ is None if no plan_
    was generated.  Raises pyke.CanNotProve if no proof is found.
prove_n(kb_name, entity_name, fixed_args, num_returns)
    This is a generator yielding two results: a tuple whose len == num_returns,
    and a plan_, for each possible proof.  Like ``prove_1``, the plan_ is None
    if no plan_ was generated.

Running and Pickling Plans
----------------------------

Once you've obtained a plan_ from ``prove_1`` or ``prove_n``, you just call
it like a normal python function.  The arguments required are simply those
specified, if any, in the `taking clause`_ of the rule_ proving the top-level
goal.

You may call the plan_ function any number of times.  You may even pickle
the plan_ for later use.  But the plans_ are constructed out of
`functools.partial`_ functions, so you need to register this with copy_reg_
before pickling the plan_:

    >>> import copy_reg
    >>> import functools
    >>> copy_reg.pickle(functools.partial,
    ...                 lambda p: (functools.partial, (p.func,) + p.args))

The program that unpickles the plan_ does not have to import any pyke
modules to be able to run the plans_.  Just unpickle and call it.

Other Functions
========================

There are a few more functions that may be useful in special situations.

The first two of these provide more general access to the fact_ lookup and
goal proof mechanisms.  The catch is that you must first convert **all**
arguments into patterns_ and create a *context* for these patterns_.  This is
discussed below_.

lookup(kb_name, entity_name, pattern_context, patterns)
    This is a generator that binds patterns_ to successive facts_.  Yields None
    for each successful match.
prove(kb_name, entity_name, pattern_context, patterns)
    A generator that binds patterns_ to successive proofs.  Yields a
    *prototype_plan* or None for each successful match.  To turn the
    prototype_plan into a python function, call create_plan() on it.
    This returns the plan_ function.

The remaining functions are:

add_case_specific_fact(kb_name, fact_name, args)
    This is an alternate to the ``assert_`` function.
get_kb(kb_name)
    Finds and returns the `knowledge base`_ by the name ``kb_name``.  Raises
    KeyError if not found.  Note that for `rule bases`_, this returns the
    active `rule base`_ where ``kb_name`` is the `rule base category`_ name.
    Thus, not all `rule bases`_ are accessable through this call.
get_rb(rb_name)
    Finds and returns the `rule base`_ by the name ``rb_name``.  Raises
    KeyError if not found.  This works for any `rule base`_, whether it is
    active or not.
init()
    This is called once automatically for you by the ``load`` function.
    You shouldn't have to call it yourself.  If you don't have any `rule
    bases`_ this isn't necessary anyway.

Creating Your Own Patterns
----------------------------------

You'll need two more pyke modules to create your own patterns_ and contexts:

    >>> from pyke import pattern, contexts

There are four kinds of patterns_:

pattern.pattern_literal(data)
    This matches the ``data`` provided.
pattern.pattern_tuple((elements), rest_var = None)
    This matches a tuple.  ``Elements`` must each be a pattern and must
    match the first *n* elements of the tuple.  ``Rest_var`` must be a
    variable (or anonymous).  It will match the rest of the tuple and is
    always bound to a (possibly empty) tuple.
contexts.variable(name)
    This will match anything the first time it is encountered.  But then
    must match the first value each additional time it is encountered.
    Calling the constructor twice with the same name produces the same
    variable and must match the same value in all of the places that it is
    used.
contexts.anonymous()
    This will match anything each time it is encountered.
    Calling the constructor many times is not a problem.

Finally, to create a *pattern context*, you need::

    contexts.simple_context()

You'll need to save this context to lookup your variable values after each
proof is yielded. This is done by either::

    some_context.lookup_data(variable_name)
    some_variable.as_data(some_context)

.. _below: `Creating Your Own Patterns`_
.. _case specific facts:
        overview/knowledge_bases/fact_bases.html#case-specific-facts
.. _copy_reg: http://docs.python.org/lib/module-copyreg.html
.. _fact: overview/knowledge_bases/fact_bases.html#facts
.. _facts: fact_
.. _functools.partial: http://docs.python.org/lib/module-functools.html
.. _knowledge base: overview/knowledge_bases/index.html
.. _.krb file: krb_syntax/index.html
.. _.krb files: `.krb file`_
.. _pattern: krb_syntax/pattern.html
.. _patterns: pattern_
.. _plan: overview/plans.html
.. _plans: plan_
.. _rule: overview/rules/index.html
.. _rules: rule_
.. _rule base: overview/knowledge_bases/rule_bases.html
.. _rule base category:
       overview/knowledge_bases/rule_bases.html#rule-base-categories
.. _rule bases: `rule base`_
.. _taking clause: krb_syntax/bc_rule.html#FIX
