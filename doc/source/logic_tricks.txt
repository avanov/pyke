.. $Id$
.. 
.. Copyright Â© 2008 Bruce Frederiksen
.. 
.. Permission is hereby granted, free of charge, to any person obtaining a copy
.. of this software and associated documentation files (the "Software"), to deal
.. in the Software without restriction, including without limitation the rights
.. to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
.. copies of the Software, and to permit persons to whom the Software is
.. furnished to do so, subject to the following conditions:
.. 
.. The above copyright notice and this permission notice shall be included in
.. all copies or substantial portions of the Software.
.. 
.. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
.. IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
.. FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
.. AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
.. LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
.. OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
.. THE SOFTWARE.

restindex
    crumb: Logic Tricks
    page-description:
        How to accomplish different logic operations with rules.
    /description
    format: rest
    encoding: utf8
    initialheaderlevel: 2
    output-encoding: utf8
    include: yes
/restindex

===================================
Logic Tricks
===================================

This describes how to accomplish different logic operations with rules_.

X OR Y
===========

For example: check for text_x($arg) OR test_y($arg).

Create a separate subgoal for the OR case, let's call it ``or_goal``.  Then use
a separate rule_ for each OR clause::

    or_goal_test_x
        use or_goal($arg)
        when
            test_x($arg)

    or_goal_test_y
        use or_goal($arg)
        when
            test_y($arg)

Then you'd use ``or_goal($arg)`` where you wanted the *OR* clause.

This can go on for any number of OR-ed clauses by just adding more rules_ for
``or_goal``.

IF X THEN Y
=============

For example: if test_x($arg) then test_y($arg).

What this means is that test_y($arg) must be true if test_x($arg) is true.
But if test_x($arg) is not true, then test_y($arg) doesn't matter so ``if
test_x($arg) then test_y($arg)`` is true.

Create a new subgoal, let's call it ``if_x_then_y``.  Use two rules_::

    if_x_then_y_if
        use if_x_then_y($arg)
        when
            test_x($arg)            # if this fails, the next rule will be used
            special.claim_goal()    # don't use any other rules for if_x_then_y
            test_y($arg)            # if this fails, the next rule will not be used, so if_x_then_y will fail.

    if_x_then_y_else
        use if_x_then_y($_)         # this rule is only used if test_x($arg) fails

NOT X
==========================

For example: not test_x($arg)

You have to be careful about *not* logic because it can mean different things.
In this example, if we try ``not test_x($arg)`` and ``$arg`` is unbound what
should happen?  Should it generate all of the different values for ``$arg``
for which ``test_x($arg)`` fails?  This generally isn't very practical
computationally!

The other interpretation is that there is **no** possible binding for ``$arg``
that makes ``test_x($arg)`` true.  In this example, ``not test_x($arg)`` would
then be false, because there is some ``$arg`` value that makes ``test_x($arg)``
true.

This second interpretation can be done using the notany_ clause.  This can
be used in both `forward chaining`_ and `backward chaining`_ rules_::

    your_rule
        use your_goal($arg)
        when
            ..
            notany
                test_x($arg)
            ..

Note that notany_ will only temporarily bind `pattern variables`_ while it
runs, but not leave any of these bindings in place (for the following premise)
after it's finished.  Notany_ always fails on backtracking_.

EXISTS X SUCH THAT Y
===============================================================

For example: there exists a ``$x`` from ``generate_x($x)``, where
``test_y($x)`` is true.

This doesn't require a new subgoal.  You can just use the following two
clauses in place of the ``exists`` test::

    generate_x($x)
    test_y($x)          # if this fails, it will backtrack and try the next value from generate_x($x)

FOR ALL X, Y
===============================================================

FOR ALL X, Y succeeds
-----------------------

For example: for all $x from generate_x($x); test_y($x) succeeds

Use the forall_ clause::

    forall
        generate_x($x)
    require
        test_y($x)

Note that all `pattern variables`_ bound in the forall_ clause are unbound
before the premise following the forall_ is run.  In this example, this
means that ``$x`` would not be bound to a value following the forall_ clause.
You can use `python premises`_ to capture the bindings of `pattern variables`_
in the forall_ clause and make them available to the premises following the
forall_::

    python x_list = []
    forall
        generate_x($x)
    require
        test_y($x)
        python x_list.append($x)
    $xs = tuple(x_list)

Note that ``x_list`` is a python variable -- not a `pattern variable`_!  It is
moved back to `pattern variable`_ ``$xs`` in the final line so that the
following premises can access it.

Forall_ always fails on backtracking_.  Consider these two techniques::

    forall_technique
        use solve_list($x_list, $x_answers)
        when
            python x_answers = []
            forall
                $x in $x_list
            require
                solve($x, $x_ans)
                python x_answers.append($x_ans)
            $x_answers = tuple(x_answers)

and::

    recursive_technique_done
        use solve_list((), ())

    recursive_technique_more
        use solve_list(($x1, *$x_rest), ($ans1, *$ans_rest))
        when
            solve($x1, $ans1)
            solve_list($x_rest, $ans_rest)

The first technique will only find the first solution and then fail on
backtracking_ (if the invoking goal doesn't like the first solution).
But the second technique will find other solutions on backtracking_.


FOR ALL X, Y fails
-----------------------

For example: for all $x from generate_x($x), not test_y($x)

In this case, just use the notany_ clause::

    notany
        generate_x($x)
        test_y($x)

.. _backtracking: overview/rules/backward_chaining.html#backtracking
.. _backward chaining: overview/rules/backward_chaining.html
.. _forall: krb_syntax/bc_rule.html#forall
.. _forward chaining: overview/rules/forward_chaining.html
.. _notany: krb_syntax/bc_rule.html#notany
.. _pattern variable: krb_syntax/pattern.html#pattern-variable
.. _pattern variables: `pattern variable`_
.. _python premises: krb_syntax/python_premise.html
.. _rule: overview/rules/index.html
.. _rules: rule_
