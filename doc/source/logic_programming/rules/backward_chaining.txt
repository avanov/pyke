.. $Id$
.. 
.. Copyright Â© 2007-2008 Bruce Frederiksen
.. 
.. Permission is hereby granted, free of charge, to any person obtaining a copy
.. of this software and associated documentation files (the "Software"), to deal
.. in the Software without restriction, including without limitation the rights
.. to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
.. copies of the Software, and to permit persons to whom the Software is
.. furnished to do so, subject to the following conditions:
.. 
.. The above copyright notice and this permission notice shall be included in
.. all copies or substantial portions of the Software.
.. 
.. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
.. IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
.. FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
.. AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
.. LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
.. OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
.. THE SOFTWARE.

restindex
    crumb: Backward Chaining
    page-description:
        Explanation of *backward-chaining* rules, including how
        *backward-chaining* and *backtracking* works.
    /description
    format: rest
    encoding: utf8
    output-encoding: utf8
    include: yes
    initialheaderlevel: 2
/restindex

=============================================
Backward Chaining
=============================================

Backward chaining rules_ are processed when your program asks Pyke a question_
(i.e., asks Pyke to prove_ a specific *goal*).  Pyke will only use activated_
`rule bases`_ to do the proof.

Overview of "Backward-Chaining"
===============================

To do backward-chaining, Pyke finds rules whose *then* part matches the *goal*
(i.e., the question).  Once it finds such a rule, it tries to (recursively)
prove all of the subgoals in the *if* part of that rule.  Some of these
subgoals are matched against facts, and others are subgoals for other
backward-chaining rules.  If all of the subgoals can be proven, the rule
succeeds and the original goal is proven.  Otherwise, the rule fails, and Pyke
tries to find another rule whose *then* part matches the goal, and so on.

So Pyke ends up linking (or *chaining*) the *if* part of the first rule to the
*then* part of the next rule.

Reviewing:

#. Pyke starts by finding a rule whose *then* part matches the goal.
#. Pyke then proceeds to process the *if* part of that rule.
#. Which may link (or chain) to the *then* part of another rule.

Since Pyke processes these rules from *then* to *if* to *then* to *if* in the
reverse manner that we normally think of using rules, it's called *backward*
chaining.

To make this more clear, Pyke has you write your backward-chaining rules
upside down by writing the *then* part first (since that's how it is
processed).

"Use", "When" Rather than "Then", "If"
======================================

But *then-if* rules sound confusing, so Pyke uses the words **use** and
**when** rather than **then** and **if**.  You can then read the rule as "use"
this statement "when" these other statements can be proven.

.. note::

   Unlike forward-chaining_ rules, Pyke only allows one statement in the
   *use* clause.

Example
=================

Consider this example::

     1  son_father
     2      use child_parent($son, $father, (), son, father)
     3      when
     4          family.son_of($son, $father, $_)
        
     5  son_mother
     6      use child_parent($son, $mother, (), son, mother)
     7      when
     8          family.son_of($son, $_, $mother)
        
     9  daughter_father
    10      use child_parent($daughter, $father, (), daughter, father)
    11      when
    12          family.daughter_of($daughter, $father, $_)
        
    13  daughter_mother
    14      use child_parent($daughter, $mother, (), daughter, mother)
    15      when
    16          family.daughter_of($daughter, $_, $mother)
        
    17  grand_parent_and_child
    18      use child_parent($grand_child, $grand_parent, (grand),
    19                       $grand_child_type, $grand_parent_type)
    20      when
    21          child_parent($grand_child, $parent, (), $grand_child_type, $_)
    22          child_parent($parent, $grand_parent, (), $_, $grand_parent_type)
        
    23  great_grand_parent_and_child
    24      use child_parent($gg_child, $gg_parent, (great, $prefix1, *$rest_prefixes),
    25                       $gg_child_type, $gg_parent_type)
    26      when
    27          child_parent($gg_child, $parent, (), $gg_child_type, $_)
    28          child_parent($parent, $gg_parent, ($prefix1, *$rest_prefixes),
    29                       $_, $gg_parent_type)

.. note::
   These rules_ draw the same conclusions as the forward-chaining_ example_.

How Backward-Chaining Rules are Run
====================================

These rules_ are not used until you ask Pyke to prove_ a goal.

The easiest way to do this is with *some_engine.prove_1* or
*some_engine.prove_n*.  Prove_1_ only returns the first proof found and
then stops (or raises ``pyke.knowledge_engine.CanNotProve``).  Prove_n_
is a generator that generates all possible proofs (which, in some cases,
might be infinite).  In both cases, you pass a tuple of data arguments and
the number of variable arguments as the last two parameters.  The total number
of arguments for the goal is the sum of the length of the data arguments
that you pass plus the number of variable arguments that you specify.

Both functions return the variable bindings for the number of variable
arguments you specified as a tuple, along with the plan_.

Running the Example
========================

    >>> from pyke import knowledge_engine
    >>> engine = knowledge_engine.engine('examples')
    >>> engine.assert_('family', 'son_of', ('michael', 'bruce', 'marilyn'))
    >>> engine.assert_('family', 'son_of', ('bruce', 'thomas', 'norma'))
    >>> engine.assert_('family', 'daughter_of', ('norma', 'allen', 'ismay'))
    >>> engine.activate('bc_example')

Noting happens this time when we activate the rule base, because there are no
forward-chaining rules here.

We want to ask the question: "What is Michael's ancestry?".  This translates
into the Pyke statement:
``bc_example.child_parent(michael, $v1, $v2, $v3, $v4)``.

.. note::
   Note that we're using the name of the rule base, ``bc_example`` rather than
   the fact base, ``family`` here.  We expect this answer to come from the
   ``bc_example`` rule base.

This is 'bc_example', 'child_parent', with ('michael',) followed by 4 pattern
variables as arguments:

    >>> for vars, no_plan in engine.prove_n('bc_example', 'child_parent',
    ...                                     ('michael',), 4):
    ...     print vars
    ('bruce', (), 'son', 'father')
    ('marilyn', (), 'son', 'mother')
    ('thomas', ('grand',), 'son', 'father')
    ('norma', ('grand',), 'son', 'mother')
    ('allen', ('great', 'grand'), 'son', 'father')
    ('ismay', ('great', 'grand'), 'son', 'mother')

We get six answers.  Each answer is a tuple of the final 4 pattern variables.
So the six proofs found were::

    bc_example.child_parent(michael, bruce, (), son, father)
    bc_example.child_parent(michael, marilyn, (), son, mother)
    bc_example.child_parent(michael, thomas, (grand), son, father)
    bc_example.child_parent(michael, norma, (grand), son, mother)
    bc_example.child_parent(michael, allen, (great, grand), son, father)
    bc_example.child_parent(michael, ismay, (great, grand), son, mother)


.. _example: forward_chaining.html#example

.. _activated: ../../using_pyke.html#setting-up-each-case
.. _fact: ../../knowledge_bases/fact_bases.html#facts
.. _facts: fact_
.. _forward-chaining: forward_chaining.html
.. _plan: ../plans.html
.. _prove: ../../using_pyke.html#proving-goals
.. _prove_1: prove_
.. _prove_n: `prove_1`_
.. _rule: index.html
.. _rule base: ../../knowledge_bases/rule_bases.html
.. _rule base category:
   ../../knowledge_bases/rule_bases.html#rule-base-categories
.. _rule bases: `rule base`_
.. _rules: rule_
.. _question: FIX
