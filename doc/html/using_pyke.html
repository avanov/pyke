<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <title>Using Pyke</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="stylesheets/pyke.css" type="text/css" />
</head>
<body>
  <table id="page-table">
    <thead class="head">
        <tr id="header1"><th id="header" colspan="3">
            &nbsp;
        </th></tr>
        <tr id="header2">
          <th id="crumb-left"></th>
          <th id="crumb-line">
            <div id="nav">
              <ul>
                  <li><a href="index.html">Home</a></li>
<li>&gt;</li>
<li>Using Pyke</li>

              </ul>
            </div>
          </th>
          <th id="crumb-right"></th>
        </tr>
    </thead>

    <tbody id="body">
        <tr id="body-tr">
          <td id="left-nav">
            <div id="left-nav-div">
              
<div class="title-nav"><a href="index.html">Home</a></div><div class="nav-branch">
<div class="normal-nav"><a href="why_pyke.html">Why Pyke?</a></div>
<div class="normal-nav"><a href="steps_to_using_pyke.html">Steps to Using Pyke</a></div>
<div class="normal-nav"><a href="installing_pyke.html">Installing Pyke</a></div>
<div class="normal-nav"><a href="logic_programming/index.html">Logic Programming</a></div>
<div class="normal-nav"><a href="knowledge_bases/index.html">Knowledge Bases</a></div>
<div class="normal-nav"><a href="pyke_syntax/index.html">Pyke Syntax</a></div>
<div class="normal-nav"><a href="using_pyke.html">Using Pyke</a></div>
<div class="normal-nav"><a href="examples.html">Examples</a></div>
<div class="normal-nav"><a href="PyCon2008-paper.html">PyCon 2008 Paper</a></div>
</div>

            </div>
            <div id="icons">
                <div id="project-page">
                  <a href="http://sourceforge.net/projects/pyke/">Pyke Project Page</a>
                </div>
                Please Make a Donation:<br />
                <a href="http://sourceforge.net/donate/index.php?group_id=207724">
                  <img src="http://images.sourceforge.net/images/project-support.jpg"
                       width="88" height="32" border="0"
                       alt="Support This Project" /> </a> <br /><br />
                Hosted by: <br />
                <!-- <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=207724&amp;type=3" width="125" height="37" border="0" alt="SourceForge.net Logo" /></a> -->
                <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=207724&amp;type=4" width="125" height="37" border="0" alt="SourceForge.net Logo" /></a>
            </div>
          </td>
          <td id="main-td">
            <div id="main">
                <a name="startcontent" id="startcontent"></a>
                <div class="document" id="using-pyke">
<h1 class="title">Using Pyke</h1>
<p>This describes how to use Pyke from within your Python program.</p>
<div class="section">
<h2><a id="initializing-pyke" name="initializing-pyke">Initializing Pyke</a></h2>
<p>There are two steps to initializing a Pyke knowledge engine:</p>
<dl class="docutils">
<dt>knowledge_engine.engine(paths = ('.',), gen_root_location = '.', gen_root_pkg = 'compiled_krb', load_fc = True, load_bc = True, load_fb = True, load_qb = True)</dt>
<dd><p class="first">The Pyke inference engine is offered
as a class so that you can instantiate multiple copies of it with different
rule bases to accomplish different tasks.
Once you have a knowledge_engine.engine object; generally, all of
the functions that you need are provided directly by this object:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from pyke import knowledge_engine
&gt;&gt;&gt; my_engine = knowledge_engine.engine('examples')
</pre>
<p>This expects either a single directory or a sequence of directories as
the <tt class="docutils literal"><span class="pre">paths</span></tt> argument.  It recursively walks each directory looking
for Pyke source files (<a class="reference" href="kfb_syntax.html">.kfb files</a>, <a class="reference" href="krb_syntax/index.html">.krb files</a>, and <a class="reference" href="kqb_syntax.html">.kqb files</a>).
Each source file that it finds is compiled, if out of date, and then
imported (depending on <tt class="docutils literal"><span class="pre">load_fc</span></tt>, <tt class="docutils literal"><span class="pre">load_bc</span></tt>, <tt class="docutils literal"><span class="pre">load_fb</span></tt> and
<tt class="docutils literal"><span class="pre">load_qb</span></tt>).  This causes all of the <a class="reference" href="knowledge_bases/rule_bases.html">rule bases</a> to be loaded and made
ready to <em>activate</em> (see below).</p>
<p>All generated Python files are placed in a mirror directory structure
under the <em>gen_root_location</em> directory in <em>gen_root_pkg</em>.  Thus, by
default, this mirrored directory structure would be rooted under the
&quot;./compiled_krb&quot; directory.  You probably want to add <tt class="docutils literal"><span class="pre">compiled_krb</span></tt> to
your subversion <tt class="docutils literal"><span class="pre">global-ignores</span></tt> option.  <em>Gen_root_pkg</em>,
<em>gen_root_location</em> and the mirrored directory structure will be created
automatically if any of them do not already exist.</p>
<p class="last">If you change some of your Pyke source files, you can create a new engine
object to compile and reload the generated Python modules without
restarting your program.  But note that you'll need to rerun your
<tt class="docutils literal"><span class="pre">add_universal_fact</span></tt> calls.</p>
</dd>
<dt><em>some_engine</em>.add_universal_fact(kb_name, fact_name, arguments)</dt>
<dd><p class="first">The <tt class="docutils literal"><span class="pre">add_universal_fact</span></tt> function is called once per <a class="reference" href="knowledge_bases/fact_bases.html#facts">fact</a>.  These <a class="reference" href="knowledge_bases/fact_bases.html#facts">facts</a>
are never deleted and apply to all <em>cases</em>.</p>
<p>Alternatively, you can place universal facts in a <a class="reference" href="kfb_syntax.html">.kfb file</a> so that
they are loaded automatically.</p>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.add_universal_fact('family', 'son_of', ('bruce', 'thomas', 'norma'))
</pre>
<p>Multiple facts with the same name are allowed.</p>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.add_universal_fact('family', 'son_of', ('david', 'bruce', 'marilyn'))
</pre>
<p>But duplicate facts (with the same arguments) are silently ignored.</p>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.add_universal_fact('family', 'son_of', ('david', 'bruce', 'marilyn'))
&gt;&gt;&gt; my_engine.get_kb('family').dump_universal_facts()
son_of('bruce', 'thomas', 'norma')
son_of('david', 'bruce', 'marilyn')
</pre>
<p class="last">These facts are accessed as <em>kb_name.fact_name(arguments)</em> within the
<a class="reference" href="krb_syntax/index.html">.krb files</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a id="setting-up-each-case" name="setting-up-each-case">Setting up Each Case</a></h2>
<p>Pyke is designed to be run multiple times for multiple <em>cases</em>.  In
general each case has its own set of starting <a class="reference" href="knowledge_bases/fact_bases.html#facts">facts</a> and may use different
<a class="reference" href="knowledge_bases/rule_bases.html">rule bases</a>, depending on the situation.</p>
<p>Three functions initialize each case:</p>
<dl class="docutils">
<dt><em>some_engine</em>.reset()</dt>
<dd>The <tt class="docutils literal"><span class="pre">reset</span></tt> function is called once to delete all of the <a class="reference" href="knowledge_bases/fact_bases.html#case-specific-facts">case specific
facts</a> from the last run.  It also deactivates all <a class="reference" href="knowledge_bases/rule_bases.html">rule bases</a>.</dd>
<dt><em>some_engine</em>.assert_(kb_name, fact_name, arguments)</dt>
<dd><p class="first">Call <tt class="docutils literal"><span class="pre">assert_</span></tt> (or the equivalent, <tt class="docutils literal"><span class="pre">add_case_specific_fact</span></tt>,
see <a class="reference" href="#other-functions">Other Functions</a>, below) for each starting <a class="reference" href="knowledge_bases/fact_bases.html#facts">fact</a> for this case.
Like universal facts, you may have multiple facts with the same name so
long as they have different arguments.</p>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.assert_('family', 'daughter_of', ('marilyn', 'arthur', 'kathleen'))
&gt;&gt;&gt; my_engine.assert_('family', 'daughter_of', ('sue', 'arthur', 'kathleen'))
&gt;&gt;&gt; my_engine.assert_('family', 'daughter_of', ('sue', 'arthur', 'kathleen'))
</pre>
<p>Duplicates with universal facts are also ignored.</p>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.assert_('family', 'son_of', ('bruce', 'thomas', 'norma'))
&gt;&gt;&gt; my_engine.get_kb('family').dump_specific_facts()
daughter_of('marilyn', 'arthur', 'kathleen')
daughter_of('sue', 'arthur', 'kathleen')
&gt;&gt;&gt; my_engine.get_kb('family').dump_universal_facts()
son_of('bruce', 'thomas', 'norma')
son_of('david', 'bruce', 'marilyn')
</pre>
<p>There is no difference within the .krb files of how universal facts
verses specific facts are used.  The only difference between the two
types of facts is that the specific facts are deleted when a reset is
done.</p>
<pre class="last doctest-block">
&gt;&gt;&gt; my_engine.reset()
&gt;&gt;&gt; my_engine.get_kb('family').dump_specific_facts()
&gt;&gt;&gt; my_engine.get_kb('family').dump_universal_facts()
son_of('bruce', 'thomas', 'norma')
son_of('david', 'bruce', 'marilyn')
</pre>
</dd>
<dt><em>some_engine</em>.activate(*rb_names)</dt>
<dd><p class="first">Then call <tt class="docutils literal"><span class="pre">activate</span></tt> to activate the appropriate <a class="reference" href="knowledge_bases/rule_bases.html">rule bases</a>.  This
may be called more than once, if desired, or it can simply take multiple
arguments.</p>
<pre class="last doctest-block">
&gt;&gt;&gt; my_engine.activate('bc_example')
</pre>
</dd>
</dl>
<p>Your Pyke engine is now ready to prove goals for this case!</p>
</div>
<div class="section">
<h2><a id="proving-goals" name="proving-goals">Proving Goals</a></h2>
<p>Two functions are provided that cover the easy cases.  More general
functions are provided in <a class="reference" href="#other-functions">Other Functions</a>, below.</p>
<dl class="docutils">
<dt><em>some_engine</em>.prove_1(kb_name, entity_name, fixed_args, num_returns)</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">Kb_name</span></tt> may name either a <a class="reference" href="knowledge_bases/fact_bases.html">fact_base</a> or an activated
<a class="reference" href="knowledge_bases/rule_bases.html#rule-base-categories">rule base category</a>.  The <tt class="docutils literal"><span class="pre">entity_name</span></tt> is the fact_name for fact_bases,
or the name of the <a class="reference" href="logic_programming/rules/backward_chaining.html">backward chaining</a> goal for <a class="reference" href="knowledge_bases/rule_bases.html">rule bases</a>.
The <tt class="docutils literal"><span class="pre">fixed_args</span></tt> are a tuple of Python values.  These form the first
group of arguments to the proof.  <tt class="docutils literal"><span class="pre">Num_returns</span></tt> specifies the number of
additional <a class="reference" href="krb_syntax/pattern.html#pattern-variable">pattern variables</a> to be appended to the arguments for the
proof.  The bindings of these pattern variables will be returned as the
answer for the proof.  For example:</p>
<blockquote>
<em>some_engine</em>.prove_1(<em>some_rule_base_category</em>, <em>some_goal</em>, (1, 2, 3), 2)</blockquote>
<p>Proves the goal:</p>
<blockquote>
<em>some_rule_base_category.some_goal</em> (1, 2, 3, $ans_0, $ans_1)</blockquote>
<p>And will return the bindings for <tt class="docutils literal"><span class="pre">$ans_0</span></tt> and <tt class="docutils literal"><span class="pre">$ans_1</span></tt> produced by
the proof.</p>
<p class="last">Returns the first proof found as a 2-tuple: a tuple of the bindings for
the <tt class="docutils literal"><span class="pre">num_returns</span></tt> pattern variables, and a <a class="reference" href="logic_programming/rules/plans.html">plan</a>.  The <a class="reference" href="logic_programming/rules/plans.html">plan</a> is <tt class="docutils literal"><span class="pre">None</span></tt>
if no <a class="reference" href="logic_programming/rules/plans.html">plan</a> was generated; otherwise, it is a Python function as
described <a class="reference" href="#running-and-pickling-plans">below</a>.</p>
</dd>
</dl>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.prove_1('bc_example', 'child_parent', ('david', 'norma'), 3)
((('grand',), 'son', 'mother'), None)
</pre>
<p>Raises <tt class="docutils literal"><span class="pre">knowledge_engine.CanNotProve</span></tt> if no proof is found.</p>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.prove_1('bc_example', 'bogus', ('david', 'norma'), 3)
Traceback (most recent call last):
    ...
CanNotProve: Can not prove bc_example.bogus(david, norma, $ans_0, $ans_1, $ans_2)
</pre>
</blockquote>
<dl class="docutils">
<dt><em>some_engine</em>.prove_n(kb_name, entity_name, fixed_args, num_returns)</dt>
<dd><p class="first">This is a generator yielding 2-tuples, a tuple whose length == num_returns
and a <a class="reference" href="logic_programming/rules/plans.html">plan</a>, for each possible proof.  Like <tt class="docutils literal"><span class="pre">prove_1</span></tt>, the <a class="reference" href="logic_programming/rules/plans.html">plan</a> is None
if no <a class="reference" href="logic_programming/rules/plans.html">plan</a> was generated.</p>
<pre class="last doctest-block">
&gt;&gt;&gt; for ans in my_engine.prove_n('bc_example', 'child_parent', ('david',), 4):
...     print ans
(('bruce', (), 'son', 'father'), None)
(('marilyn', (), 'son', 'mother'), None)
(('thomas', ('grand',), 'son', 'father'), None)
(('norma', ('grand',), 'son', 'mother'), None)
</pre>
</dd>
</dl>
<div class="section">
<h3><a id="running-and-pickling-plans" name="running-and-pickling-plans">Running and Pickling Plans</a></h3>
<p>Once you've obtained a <a class="reference" href="logic_programming/rules/plans.html">plan</a> from <tt class="docutils literal"><span class="pre">prove_1</span></tt> or <tt class="docutils literal"><span class="pre">prove_n</span></tt>, you just call
it like a normal Python function.  The arguments required are simply those
specified, if any, in the <a class="reference" href="krb_syntax/bc_rule.html#taking-clause">taking clause</a> of the <a class="reference" href="logic_programming/rules/index.html">rule</a> proving the top-level
goal.</p>
<p>You may call the <a class="reference" href="logic_programming/rules/plans.html">plan</a> function any number of times.  You may even pickle
the <a class="reference" href="logic_programming/rules/plans.html">plan</a> for later use.  But the <a class="reference" href="logic_programming/rules/plans.html">plans</a> are constructed out of
<a class="reference" href="http://docs.python.org/lib/module-functools.html">functools.partial</a> functions, so you need to register this with <a class="reference" href="http://docs.python.org/lib/module-copyreg.html">copy_reg</a>
before pickling the <a class="reference" href="logic_programming/rules/plans.html">plan</a>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import copy_reg
&gt;&gt;&gt; import functools
&gt;&gt;&gt; copy_reg.pickle(functools.partial,
...                 lambda p: (functools.partial, (p.func,) + p.args))
</pre>
</blockquote>
<p>No special code is required to unpickle a <a class="reference" href="logic_programming/rules/plans.html">plan</a>.  Just unpickle and call it.
(Unpickling the <a class="reference" href="logic_programming/rules/plans.html">plan</a> only imports one small Pyke module to be able to run
the <a class="reference" href="logic_programming/rules/plans.html">plan</a>).</p>
</div>
<div class="section">
<h3><a id="tracing-rules" name="tracing-rules">Tracing Rules</a></h3>
<p>Individual rules may be traced to aid in debugging.  The <tt class="docutils literal"><span class="pre">trace</span></tt> function
takes two arguments: the rule base name, and the name of the rule to trace:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.trace('bc_example', 'grand_parent_and_child')
&gt;&gt;&gt; my_engine.prove_1('bc_example', 'child_parent', ('david', 'norma'), 3)
bc_example.grand_parent_and_child('david', 'norma', '$ans_0', '$ans_1', '$ans_2')
bc_example.grand_parent_and_child succeeded with ('david', 'norma', ('grand',), 'son', 'mother')
((('grand',), 'son', 'mother'), None)
</pre>
</blockquote>
<p>This can be done either before or after rule base activation and will remain
in effect until you call <tt class="docutils literal"><span class="pre">untrace</span></tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; my_engine.untrace('bc_example', 'grand_parent_and_child')
&gt;&gt;&gt; my_engine.prove_1('bc_example', 'child_parent', ('david', 'norma'), 3)
((('grand',), 'son', 'mother'), None)
</pre>
</blockquote>
</div>
<div class="section">
<h3><a id="krb-traceback" name="krb-traceback">Krb_traceback</a></h3>
<p>A handy traceback module is provided to convert Python functions, lines and
line numbers to the <a class="reference" href="krb_syntax/index.html">.krb file</a> rule names, lines and line numbers in Python
traceback.  This makes it much easier to read the tracebacks that occur
during proofs.</p>
<p>The krb_traceback module has exactly the same functions as the standard
Python <a class="reference" href="http://docs.python.org/lib/module-traceback.html">traceback</a> module, but they convert the generated Python function
information into <a class="reference" href="krb_syntax/index.html">.krb file</a> information.  They also delete the
intervening Python functions between subgoal proofs.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import sys
&gt;&gt;&gt; from pyke import knowledge_engine
&gt;&gt;&gt; from pyke import krb_traceback
&gt;&gt;&gt;
&gt;&gt;&gt; my_engine = knowledge_engine.engine('examples')
&gt;&gt;&gt; my_engine.activate('error_test')
&gt;&gt;&gt; try:                                            # doctest: +ELLIPSIS
...     my_engine.prove_1('error_test', 'goal', (), 0)
... except:
...     krb_traceback.print_exc(None, sys.stdout)   # sys.stdout needed for doctest
Traceback (most recent call last):
  File &quot;&lt;doctest using_pyke.txt[31]&gt;&quot;, line 2, in &lt;module&gt;
    my_engine.prove_1('error_test', 'goal', (), 0)
  File &quot;...knowledge_engine.py&quot;, line 182, in prove_1
    return self.prove_n(kb_name, entity_name, fixed_args, num_returns) \
  File &quot;...knowledge_engine.py&quot;, line 169, in prove_n
    for arg in fixed_args) + vars):
  File &quot;...rule_base.py&quot;, line 37, in next
    return self.iterator.next()
  File &quot;...knowledge_engine.py&quot;, line 39, in from_iterable
    for x in iterable: yield x
  File &quot;...knowledge_engine.py&quot;, line 39, in from_iterable
    for x in iterable: yield x
  File &quot;...error_test.krb&quot;, line 26, in rule1
    goal2()
  File &quot;...error_test.krb&quot;, line 31, in rule2
    goal3()
  File &quot;...error_test.krb&quot;, line 36, in rule3
    goal4()
  File &quot;...error_test.krb&quot;, line 41, in rule4
    check $bar &gt; 0
  File &quot;...contexts.py&quot;, line 227, in lookup_data
    raise KeyError(&quot;$%s not bound&quot; % var_name)
KeyError: '$bar not bound'
</pre>
</blockquote>
</div>
</div>
<div class="section">
<h2><a id="other-functions" name="other-functions">Other Functions</a></h2>
<p>There are a few more functions that may be useful in special situations.</p>
<p>The first two of these provide more general access to the <a class="reference" href="knowledge_bases/fact_bases.html#facts">fact</a> lookup and
goal proof mechanisms.  The catch is that you must first convert <strong>all</strong>
arguments into <a class="reference" href="krb_syntax/pattern.html">patterns</a> and create a <em>context</em> for these <a class="reference" href="krb_syntax/pattern.html">patterns</a>.  This is
discussed <a class="reference" href="#creating-your-own-patterns">below</a>.</p>
<dl class="docutils">
<dt><em>some_engine</em>.lookup(kb_name, entity_name, pattern_context, patterns)</dt>
<dd>This is a generator that binds <a class="reference" href="krb_syntax/pattern.html">patterns</a> to successive <a class="reference" href="knowledge_bases/fact_bases.html#facts">facts</a>.  Yields None
for each successful match.</dd>
<dt><em>some_engine</em>.prove(kb_name, entity_name, pattern_context, patterns)</dt>
<dd>A generator that binds <a class="reference" href="krb_syntax/pattern.html">patterns</a> to successive proofs.  Yields a
<em>prototype_plan</em> or <tt class="docutils literal"><span class="pre">None</span></tt> for each successful match.  To turn the
prototype_plan into a Python function, use <em>prototype_plan</em>.create_plan().
This returns the <a class="reference" href="logic_programming/rules/plans.html">plan</a> function.</dd>
</dl>
<p>The remaining functions are:</p>
<dl class="docutils">
<dt><em>some_engine</em>.add_case_specific_fact(kb_name, fact_name, args)</dt>
<dd>This is an alternate to the <tt class="docutils literal"><span class="pre">assert_</span></tt> function.</dd>
<dt><em>some_engine</em>.get_kb(kb_name)</dt>
<dd>Finds and returns the <a class="reference" href="knowledge_bases/index.html">knowledge base</a> by the name <tt class="docutils literal"><span class="pre">kb_name</span></tt>.  Raises
KeyError if not found.  Note that for <a class="reference" href="knowledge_bases/rule_bases.html">rule bases</a>, this returns the
active <a class="reference" href="knowledge_bases/rule_bases.html">rule base</a> where <tt class="docutils literal"><span class="pre">kb_name</span></tt> is the <a class="reference" href="knowledge_bases/rule_bases.html#rule-base-categories">rule base category</a> name.
Thus, not all <a class="reference" href="knowledge_bases/rule_bases.html">rule bases</a> are accessible through this call.</dd>
<dt><em>some_engine</em>.get_rb(rb_name)</dt>
<dd>Finds and returns the <a class="reference" href="knowledge_bases/rule_bases.html">rule base</a> by the name <tt class="docutils literal"><span class="pre">rb_name</span></tt>.  Raises
KeyError if not found.  This works for any <a class="reference" href="knowledge_bases/rule_bases.html">rule base</a>, whether it is
active or not.</dd>
<dt><em>some_engine</em>.print_stats([f = sys.stdout])</dt>
<dd>Prints a brief set of statistics for each knowledge base to file <tt class="docutils literal"><span class="pre">f</span></tt>.
These are reset by the <tt class="docutils literal"><span class="pre">reset</span></tt> function.  This will show how many facts
were asserted, and counts of how many forward-chaining rules were triggered
and rerun, as well as counts of how many backward-chaining goals were tried,
and how many backward-chaining rules matched, succeeded and failed.
Note that one backward-chaining rule may succeed many times through
backtracking.</dd>
</dl>
<div class="section">
<h3><a id="creating-your-own-patterns" name="creating-your-own-patterns">Creating Your Own Patterns</a></h3>
<p>You'll need two more Pyke modules to create your own <a class="reference" href="krb_syntax/pattern.html">patterns</a> and contexts:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from pyke import pattern, contexts
</pre>
</blockquote>
<p>There are four kinds of <a class="reference" href="krb_syntax/pattern.html">patterns</a>:</p>
<dl class="docutils">
<dt>pattern.pattern_literal(data)</dt>
<dd>This matches the <tt class="docutils literal"><span class="pre">data</span></tt> provided.</dd>
<dt>pattern.pattern_tuple((elements), rest_var = None)</dt>
<dd>This matches a tuple.  <tt class="docutils literal"><span class="pre">Elements</span></tt> must each be a pattern and must
match the first <em>n</em> elements of the tuple.  <tt class="docutils literal"><span class="pre">Rest_var</span></tt> must be a
variable (or anonymous).  It will match the rest of the tuple and is
always bound to a (possibly empty) tuple.</dd>
<dt>contexts.variable(name)</dt>
<dd>This will match anything the first time it is encountered.  But then
must match the first value each additional time it is encountered.
Calling the constructor twice with the same name produces the same
variable and must match the same value in all of the places that it is
used.</dd>
<dt>contexts.anonymous(name)</dt>
<dd>This will match anything each time it is encountered.
Calling the constructor many times with the same name is not a problem.
The name must start with an underscore.</dd>
</dl>
<p>Finally, to create a <em>pattern context</em>, you need:</p>
<blockquote>
contexts.simple_context()</blockquote>
<p>You'll need to save this context to lookup your variable values after each
proof is yielded. This is done by either:</p>
<blockquote>
<div class="line-block">
<div class="line"><em>some_context</em>.lookup_data(<em>variable_name</em>)</div>
<div class="line"><em>some_variable</em>.as_data(<em>some_context</em>)</div>
</div>
</blockquote>
</div>
</div>
</div>

                <!-- <div id="return-to-top">
                       <a href="#">Return to Top</a>
                     </div>
                -->
            </div>
          </td>
          <td id="right-nav">
            <div id="right-nav-div">
                <h3>More:</h3>
<div class="right-item"><a href="why_pyke.html">Why Pyke?</a><p>What does Pyke do for me?</p>
</div>
<div class="right-item"><a href="steps_to_using_pyke.html">Steps to Using Pyke</a><p>A brief list of the steps involved in programming in Pyke (with lots
of links).</p>
</div>
<div class="right-item"><a href="installing_pyke.html">Installing Pyke</a><p>System Requirements and installing Pyke.</p>
</div>
<div class="right-item"><a href="logic_programming/index.html">Logic Programming Tutorial</a><p>An tutorial on logic programming in Pyke, including <em>statements</em>,
<em>pattern matching</em> and <em>rules</em>.</p>
</div>
<div class="right-item"><a href="knowledge_bases/index.html">Knowledge Bases</a><p>Knowledge is made up of both <em>facts</em> and <em>rules</em>.  These are gathered
into named repositories called <em>knowledge bases</em>.</p>
</div>
<div class="right-item"><a href="pyke_syntax/index.html">Pyke Syntax</a><p>The syntax of Pyke's three different kinds of source files.</p>
</div>
<div class="right-item"><a href="using_pyke.html">Using Pyke</a><p>How your Python program uses Pyke.</p>
</div>
<div class="right-item"><a href="examples.html">Examples</a><p>An overview of the examples provided with Pyke.</p>
</div>
<div class="right-item"><a href="PyCon2008-paper.html">Applying Expert System Technology to Code Reuse with Pyke</a><p>Paper presented at the PyCon 2008 conference in Chicago.</p>
</div>

            </div>
          </td>
        </tr>
    </tbody>

    <tfoot id="foot">
        <tr id="foot2">
          <td id="copyright" colspan="3">
            Copyright &copy; 2007 Bruce Frederiksen
          </td>
        </tr>
    </tfoot>
  </table>

  <div id="last-modified">
    Page last modified Mon, Aug 11 2008.
  </div>

</body>
</html>
