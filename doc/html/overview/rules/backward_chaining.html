<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <title>Backward Chaining</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../../stylesheets/pyke.css" type="text/css" />
</head>
<body>
  <table id="page-table">
    <thead class="head">
        <tr id="header1"><th id="header" colspan="3">
            &nbsp;
        </th></tr>
        <tr id="header2">
          <th id="crumb-left"></th>
          <th id="crumb-line">
            <div id="nav">
              <ul>
                  <li><a href="../../index.html">Home</a></li>
<li>&gt;</li>
<li><a href="../index.html">Overview</a></li>
<li>&gt;</li>
<li><a href="index.html">Rules</a></li>
<li>&gt;</li>
<li>Backward Chaining</li>

              </ul>
            </div>
          </th>
          <th id="crumb-right"></th>
        </tr>
    </thead>

    <tbody id="body">
        <tr id="body-tr">
          <td id="left-nav">
            <div id="left-nav-div">
              
<div class="title-nav"><a href="../../index.html">Home</a></div><div class="nav-branch">

<div class="title-nav"><a href="../index.html">Overview</a></div><div class="nav-branch">
<div class="normal-nav"><a href="../knowledge_bases/index.html">Knowledge Bases</a></div>

<div class="title-nav"><a href="index.html">Rules</a></div><div class="nav-branch">
<div class="normal-nav"><a href="forward_chaining.html">Forward Chaining</a></div>
<div class="normal-nav"><a href="backward_chaining.html">Backward Chaining</a></div>
</div>
<div class="normal-nav"><a href="../plans/index.html">Plans</a></div>
</div>
<div class="normal-nav"><a href="../../krb_syntax/index.html">KRB Syntax</a></div>
<div class="normal-nav"><a href="../../interfacing_to_pyke/index.html">Interfacing to PyKE</a></div>
<div class="normal-nav"><a href="../../pyke_internals/index.html">Internals</a></div>
</div>

            </div>
            <div id="icons">
                <div id="project-page">
                  <a href="http://sourceforge.net/projects/pyke/">PyKE Project Page</a>
                </div>
                Hosted by: <br />
                <!-- <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=207724&amp;type=3" width="125" height="37" border="0" alt="SourceForge.net Logo" /></a> -->
                <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=207724&amp;type=4" width="125" height="37" border="0" alt="SourceForge.net Logo" /></a>
            </div>
          </td>
          <td id="main-td">
            <div id="main">
                <a name="startcontent" id="startcontent"></a>
                <div class="document" id="backward-chaining">
<h1 class="title">Backward Chaining</h1>
<p>Backward chaining rules are processed when your program asks pyke to prove
a specific <em>goal</em>.  Pyke will only use activated rule bases to do the
proof.</p>
<p>Consider this example:</p>
<pre class="literal-block">
 1  son_father:
 2      use child_parent($son, $father, (), son, father)
 3      when
 4          family.son_of($son, $father, $_)

 5  son_mother:
 6      use child_parent($son, $mother, (), son, mother)
 7      when
 8          family.son_of($son, $_, $mother)

 9  daughter_father:
10      use child_parent($daughter, $father, (), daughter, father)
11      when
12          family.daughter_of($daughter, $father, $_)

13  daughter_mother:
14      use child_parent($daughter, $mother, (), daughter, mother)
15      when
16          family.daughter_of($daughter, $_, $mother)

17  grand_parent_and_child:
18      use child_parent($grand_child, $grand_parent, (grand),
19                       $grand_child_type, $grand_parent_type)
20      when
21          child_parent($grand_child, $parent, (), $grand_child_type, $_)
22          child_parent($parent, $grand_parent, (), $_, $grand_parent_type)

23  great_grand_parent_and_child:
24      use child_parent($gg_child, $gg_parent, (great, $prefix1, *$rest_prefixes),
25                       $gg_child_type, $gg_parent_type)
26      when
27          child_parent($gg_child, $parent, (), $gg_child_type, $_)
28          child_parent($parent, $gg_parent, ($prefix1, *$rest_prefixes),
29                       $_, $gg_parent_type)
</pre>
<p>These rules draw the same conclusions as the <em>forward-chaining</em> example;
but you'll notice three differences:</p>
<ol class="arabic simple">
<li>The rule's <strong>if</strong> and <strong>then</strong> parts are reversed.</li>
<li>The rules use different keywords: <tt class="docutils literal"><span class="pre">use</span></tt> for the <strong>then</strong> clause
and <tt class="docutils literal"><span class="pre">when</span></tt> for the <strong>if</strong> clause.</li>
<li>The facts established by backward-chaining do not have a knowledge
base name prefix.  In this case, the knowledge base name defaults to
the rule base category of this rule base (it's root rule base name).</li>
</ol>
<p>These rules are not used until you ask pyke to prove a goal.</p>
<p>The easiest way
to do this is with <tt class="docutils literal"><span class="pre">pyke.prove_1</span></tt> or <tt class="docutils literal"><span class="pre">pyke.prove_n</span></tt>.  <tt class="docutils literal"><span class="pre">Prove_1</span></tt> only
returns the first proof found and then stops (or raises pyke.CanNotProve).
<tt class="docutils literal"><span class="pre">Prove_n</span></tt> is a generator that generates all possible proofs (which, in
some cases, might be infinite).  In both cases, you pass a tuple of
arguments and the number of variable arguments as the last two parameters.
The total number of arguments for the goal is the sum of the length of the
actual arguments that you pass plus the number of variable arguments that you
specify.
Both functions return the variable bindings for the number of variable
arguments you specified as a tuple, along with the plan (to be discussed
later).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import pyke
&gt;&gt;&gt; pyke.load('examples')
&gt;&gt;&gt; pyke.assert_('family', 'son_of', ('michael', 'bruce', 'marilyn'))
&gt;&gt;&gt; pyke.assert_('family', 'son_of', ('bruce', 'thomas', 'norma'))
&gt;&gt;&gt; pyke.assert_('family', 'daughter_of', ('norma', 'allen', 'ismay'))
&gt;&gt;&gt; pyke.activate('bc_example')
&gt;&gt;&gt; for vars, no_plan in pyke.prove_n('bc_example', 'child_parent',
...                                   ('michael',), 4):
...     print vars
('bruce', (), 'son', 'father')
('marilyn', (), 'son', 'mother')
('thomas', ('grand',), 'son', 'father')
('norma', ('grand',), 'son', 'mother')
('allen', ('great', 'grand'), 'son', 'father')
('ismay', ('great', 'grand'), 'son', 'mother')
</pre>
</blockquote>
<p>Pyke performs the proof by:</p>
<ol class="arabic simple">
<li>Checking to see if the goal is simply a known fact.
If so, it has a proof!</li>
<li>Look for the first backward-chaining rule that concludes the goal
in its <tt class="docutils literal"><span class="pre">use</span></tt> clause.<ul>
<li>If not found, the goal fails.</li>
<li>If found, try to recursively prove all of the subgoals in the
rule's <tt class="docutils literal"><span class="pre">when</span></tt> clause.<ul>
<li>If this succeeds, the goal is proven.</li>
<li>If this fails, go back to step 2 and look for the next rule
that concludes the goal in its <tt class="docutils literal"><span class="pre">use</span></tt> clause.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Note how the rules are combined in the opposite direction from
forward-chaining rules.  Here the first rule's <strong>if</strong> (<tt class="docutils literal"><span class="pre">when</span></tt>) clause is
linked backwards to the next rule's <strong>then</strong> (<tt class="docutils literal"><span class="pre">use</span></tt>) clause.  This is why
these rules are called <em>backward-chaining</em> rules.</p>
<p>Also note that while processing each subgoal within a rule's <tt class="docutils literal"><span class="pre">when</span></tt> clause:</p>
<ul class="simple">
<li>If pyke succeeds at proving the subgoal:<ul>
<li>Pyke will proceed to the next subgoal within the <tt class="docutils literal"><span class="pre">when</span></tt> clause.</li>
<li>If pyke reaches the end of the <tt class="docutils literal"><span class="pre">when</span></tt> clause, the rule succeeds.</li>
</ul>
</li>
<li>If pyke fails at proving the subgoal:<ul>
<li>Pyke will back up to the prior subgoal within the <tt class="docutils literal"><span class="pre">when</span></tt> clause
and try to find another proof for it.  The process starts over
from this prior subgoal.</li>
<li>If pyke reaches the beginning of the <tt class="docutils literal"><span class="pre">when</span></tt> clause, the rule
fails.</li>
</ul>
</li>
</ul>
<p>Thus, execution within each rule's <tt class="docutils literal"><span class="pre">when</span></tt> clause proceeds both forwards
and backwards up and down the list of subgoals, depending on whether each
subgoal succeeds or fails.  The process of backing up in the <tt class="docutils literal"><span class="pre">when</span></tt>
clause to try alternate subproofs is called <em>backtracking</em>.</p>
</div>

                <div id="return-to-top"><a href="#">Return to Top</a></div>
            </div>
          </td>
          <td id="right-nav">
            <div id="right-nav-div">
                <h3>Pages:</h3>
<div class="right-item"><a href="forward_chaining.html">Forward Chaining</a><p>Explanation of forward-chaining rules.</p>
</div>
<div class="right-item"><a href="backward_chaining.html">Backward Chaining</a><p>Explanation of backward-chaining rules.</p>
</div>

            </div>
          </td>
        </tr>
    </tbody>

    <tfoot id="foot">
        <tr id="foot2">
          <td id="copyright" colspan="3">
            Copyright &copy; 2007 Bruce Frederiksen
          </td>
        </tr>
    </tfoot>
  </table>

  <div id="last-modified">Page last modified Sun Nov  4 18:36:43 2007.</div>

</body>
</html>
